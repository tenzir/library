id: misp
name: MISP
author: Tenzir
author_icon: https://raw.githubusercontent.com/tenzir/library/main/.tenzir.svg
package_icon: |
  https://raw.githubusercontent.com/tenzir/library/main/misp/package.svg

description: |
  MISP (Malware Information Sharing Platform) is an open-source software
  solution for gathering, sharing, storing, and correlating Indicators of
  Compromise from cyberattacks, threat intelligence, and financial fraud.
  It fosters collaboration between organizations, enabling them to proactively
  share threat data to improve collective cybersecurity defense and incident
  response.

  This package provides the `misp` context for enrichment and pipelines that
  subscribe to the MISP ZeroMQ real time event stream or periodically fetch
  the latest events via the API.

categories:
- source

inputs:
  api-key-secret:
    name: API key secret name
    description: |
      Your MISP API key
    default: MISP_API_KEY

  refresh-interval:
    name: Context update interval
    description: |
      The duration between context updates that fetch attributes from the API.
    default: 1h

  base-url:
    name: Base API endpoint URL
    description: |
      The base URL of the MISP instance.
    default: "https://misp.local"

pipelines:
  fetch-attributes:
    name: Fetch MISP Attributes
    description: |
      Periodically fetches the attributes of all events and publishes it to the `misp.attributes` topic.
    disabled: true
    definition: |
      let $base_url = "{{ inputs.base-url }}"
      let $url = $base_url + "/attributes/restSearch"
      let $interval = {{ inputs.refresh-interval }}
      every $interval {
        from_http $url, headers={
          Authorization: secret("{{ inputs.api-key-secret }}"),
          Accept: "application/json",
        }, body={
          from: now() - $interval -1d
        }, error_field=err {
          read_json raw=true
        }
      }
      unroll response.Attribute
      this = response.Attribute
      // Fix up types because we pass raw=true to read_ndjson above.
      timestamp = from_epoch(int(timestamp) * 1s)
      first_seen = from_epoch(int(first_seen) * 1s)
      last_seen = from_epoch(int(last_seen) * 1s)
      Event.timestamp = from_epoch(int(Event.timestamp) * 1s)
      @name = "misp.attribute"
      publish "misp"

  fetch-events:
    name: Fetch MISP Events
    description: |
      Periodically fetches the events and publishes them to the `misp` topic.
    definition: |
      let $base_url = "{{ inputs.base-url }}"
      let $url = $base_url + "/events/restSearch"
      let $interval = {{ inputs.refresh-interval }}
      every $interval {
        from_http $url, headers={
          Authorization: secret("{{ inputs.api-key-secret }}"),
          Accept: "application/json",
        }, body={
          from: now() - $interval -1d
        } {
          read_json raw=true
        }
      }
      unroll response
      this = response.Event
      // Fix up types because we pass raw=true to read_ndjson above.
      timestamp = from_epoch(int(timestamp) * 1s)
      @name = "misp.event"
      publish "misp"

  normalize-attributes-to-ocsf:
    name: Normalize MISP attributes to OCSF
    description: |
      Converts MISP attributes to OCSF OSINT objects.
    definition: |
      subscribe "misp"
      where @name == "misp.attribute"
      // Structure data for OCSF mapping
      this = {osint: {}, misp: this}

      // ------ OSINT Inventory Info --------
      // Map MISP threat level to OCSF severity (invert the scale)
      let $threat_level_map = {
        "1": 4,  // High → High
        "2": 3,  // Medium → Medium
        "3": 2,  // Low → Low
        "4": 1,  // Undefined → Informational
      }

      // Map MISP analysis state to OCSF status
      let $analysis_status_map = {
        "0": 0,   // Initial → Unknown
        "1": 99,  // Ongoing → Other
        "2": 1,   // Completed → Success
      }

      // Map MISP attributes to OCSF OSINT object
      osint = {
        value: move misp.value,
        comment: move misp.comment,
        category: move misp.category,
        uid: move misp.uuid,
        created_time: move misp.timestamp,
        // TODO: we need a table from misp type to ocsf type_id.
        type_id: 1,  // Default to IP Address for network indicators
        confidence_id: 1,  // Default to Low confidence
        tlp: "CLEAR",  // Default TLP marking
        severity_id: $threat_level_map[move misp.Event.threat_level_id]? else 1,
      }

      // Adjust confidence for IDS indicators
      osint.confidence_id = 3
      // TODO: should we add this?
      // where misp.to_ids == true

      // Remove fields that were used in mapping logic
      drop misp.to_ids

      // ------ OCSF Event Classification --------
      ocsf = {}
      // Classification
      ocsf.activity_id = 2
      ocsf.activity_name = "Collect"
      ocsf.category_uid = 5
      ocsf.category_name = "Discovery"
      ocsf.class_uid = 5021
      ocsf.class_name = "OSINT Inventory Info"
      ocsf.severity_id = 1
      ocsf.severity = "Informational"
      ocsf.type_uid = ocsf.class_uid * 100 + ocsf.activity_id
      ocsf.status_id = $analysis_status_map[move misp.Event.analysis]? else 0
      ocsf.status = "Unknown"

      // Context
      ocsf.actor = {
        app_name: "Tenzir"
      }
      ocsf.metadata = {
        product: {
          name: "MISP",
        },
        version: "1.5.0",
      }
      ocsf.time = move misp.Event.timestamp

      // Primary - OSINT data array
      ocsf.osint = [osint]

      // ------ Finalize --------
      move ocsf.unmapped = misp
      this = ocsf
      @name = "ocsf.osint_inventory_info"
      ocsf::apply
      publish "ocsf"

  normalize-events-to-ocsf:
    definition: |
      subscribe "misp"
      where @name == "misp.event"

      // ------ OSINT Inventory Info --------
      // Map MISP threat level to OCSF severity (invert the scale)
      let $threat_level_map = {
        "1": 4,  // High → High
        "2": 3,  // Medium → Medium
        "3": 2,  // Low → Low
        "4": 1,  // Undefined → Informational
      }

      // Map MISP analysis state to OCSF status
      let $analysis_status_map = {
        "0": 0,   // Initial → Unknown
        "1": 99,  // Ongoing → Other
        "2": 1,   // Completed → Success
      }

      let $type_ids = {
        "ip-dst": 1,
        "ip-src": 1,
        domain: 2,
        hostname: 3,
        url: 5,
        "email-src": 9,
        "email-dst": 9,
        AS: 99,
        filename: 11,
        md5: 4,
        sha1: 4,
        sha256: 4,
        "size-in-bytes": 11,
        "file-type": 11,
        "mime-type": 11,
        mutex: 99,
        "process-name": 99,
        pid: 99,
        port: 99,
        "user-agent": 6,
        comment: 0,
        text: 0,
        vulnerability: 10,
        link: 5,
      }

      this = {ocsf: {}, misp: this}

      // ------ OCSF Event Classification --------
      ocsf = {}
      // Classification
      ocsf.activity_id = 2
      ocsf.activity_name = "Collect"
      ocsf.category_uid = 5
      ocsf.category_name = "Discovery"
      ocsf.class_uid = 5021
      ocsf.class_name = "OSINT Inventory Info"
      ocsf.severity_id = 1
      ocsf.severity = "Informational"
      ocsf.type_uid = ocsf.class_uid * 100 + ocsf.activity_id
      ocsf.status_id = $analysis_status_map[move misp.analysis]? else 0
      ocsf.severity_id = $threat_level_map[move misp.threat_level_id]? else 1

      // Context
      ocsf.actor = {
        app_name: "Tenzir"
      }
      ocsf.metadata = {
        product: {
          name: "MISP",
          vendor_name: "CIRCL",
        },
        uid: move misp.uuid,
        version: "1.5.0",
      }
      ocsf.time = move misp.timestamp

      // TODO for later
      //ocsf.is_alert = misp.Attribute.where(x => x.to_ids == true).length() != 0

      ocsf.osint = misp.Attribute.map(x => {
        category: x.category,
        created_time: from_epoch(int(x.timestamp) * 1s),
        creator: {
          name: misp.Orgc.name,
          uid: misp.Orgc.uuid,
        },
        desc: x.comment,
        external_uid: x.uuid,
        severity_id: ocsf.severity_id,
        // TODO: Figure out how to assign `null` if no tlp tag in the source.
        tlp: misp.Tag.where(x => x.name.starts_with("tlp:"))[0]?.name?.slice(begin=4).to_upper(),
        type_id: $type_ids[x.type]? else 99,
        value: x.value,
      })

      drop misp.Attribute?

      drop misp.Galaxy?
      drop misp.Object?
      drop misp.Tag?

      // ------ Finalize --------
      move ocsf.unmapped = misp
      this = ocsf
      @name = "ocsf.osint_inventory_info"
      ocsf::apply
      publish "ocsf"

  send-events-with-osint-as-sightings:
    name: Submit OCSF events with OSINT profile as to MISP as sightings
    description: |
      Sends sightings to MISP for all events that have an OSINT profile.
    definition: |
      let $misp = "{{ inputs.base-url }}"
      subscribe "ocsf-osint"
      select time, osint
      unroll osint
      http f"{$misp}/sightings/add",
        headers={
          Authorization: secret("MISP_API_KEY"),
          Accept: "application/json",
        },
        body={
          source: metadata.uid,
          // The event timestamp is equivalent to the sighting timestamp.
          // Explicitly setting it ensures that the sighting submission is not using
          // the current wallclock time, which allows us to ship "retro-sightings".
          timestamp: time.since_epoch().count_seconds(),
          // MISP creates a sighting for each matching value in the array.
          value: osint.value,
       }
      discard // TODO: remove after we have to_http.
