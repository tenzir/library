id: cisco-umbrella
name: Cisco Umbrella
author: Tenzir
author_icon: https://raw.githubusercontent.com/tenzir/library/main/author.svg
package_icon: https://raw.githubusercontent.com/tenzir/library/main/cisco-umbrella/package.svg
description: |
  The [Cisco Umbrella](https://docs.umbrella.com/deployment-umbrella/docs/welcome-to-cisco-umbrella) package
  onboards [DNS Log data](https://docs.umbrella.com/deployment-umbrella/docs/dns-log-formats) from
  a [Cisco Umbrella S3 Bucket](https://docs.umbrella.com/deployment-umbrella/docs/log-management#logging-to-amazon-s3).
categories:
- sources
- mappings

inputs:
  aws-access-key-id:
    name: AWS Access Key ID
    description: |
      The AWS access key id.
    default: "XXXXXXXXXXXXXXXXXXXX"
  aws-secret-access-key:
    name: AWS Secret Access Key
    description: |
      The AWS secret access key.
    default: "YYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYY"
  aws-region:
    name: AWS Region
    description: |
      The AWS Region of the log bucket.
    default: eu-central-1
  s3-url:
    name: S3 URL
    description: |
      The S3 URL in which to look for files.
    default: "s3://cisco-managed-eu-central-1/0000000_xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx"
  poll-frequency:
    name: The poll frequency for the SIEM Integration API
    description: |
      How to often to check for new files
    default: 15m

pipelines:
  onboard-events:
    name: Onboard Cisco Umbrella DNS logs
    description: |
      The pipeline periodically checks the configured S3 bucket for new log files,
      onboarding any that are detected. Any new files are downloaded, decompressed,
      parsed, and published as `cisco.umbrella.dns` events onto the `cisco` topic.
    definition: |
      every {{ inputs.poll-frequency }} {
        shell r#"
          # TODO: We want to switch to `remote {config}` as the first operator for
          # more robust results.
          export TENZIR_STATE_DIR=`tenzir --tql2 'from {dir: config().tenzir["state-directory"]} | write_lines'`
          export UV_CACHE_DIR=/tmp/cache/uv
          cat >/tmp/script.py <<END

      import boto3
      import io
      import json
      import sys
      import re
      import os
      from datetime import datetime, timezone

      STATE_DIR = os.environ['TENZIR_STATE_DIR']
      STATE_FILE = STATE_DIR + '/umbrella_file_list.json'

      def list_s3_files(s3, bucket_name: str, prefix: str) -> list[str]:
          files = []

          paginator = s3.get_paginator('list_objects_v2')
          for page in paginator.paginate(Bucket=bucket_name, Prefix=prefix):
              if 'Contents' in page:
                  files.extend([obj['Key'] for obj in page['Contents']])

          return files


      def download_s3_file(s3, bucket: str, key: str):
          with io.BytesIO() as inmemory_file:
              s3.download_fileobj(bucket, key, inmemory_file)
              return inmemory_file.getvalue()


      def main():
          session = boto3.Session(
              region_name="{{ inputs.aws-region }}",
              aws_access_key_id="{{ inputs.aws-access-key-id }}",
              aws_secret_access_key="{{ inputs.aws-secret-access-key }}",
          )
          s3 = session.client('s3')
          now = datetime.now(timezone.utc).isoformat()

          s3_url = "{{ inputs.s3-url }}"
          pattern = r'^s3://([^/]+)/(.+)$'
          match = re.match(pattern, s3_url)
          if not match:
              raise ValueError(f"Invalid S3 URL, expected something like 's3://bucket/prefix': {s3_url}")
          bucket, prefix = match.groups()

          # On cisco-managed buckets, permissions are set up so that you cannot 'list' the customer-specific
          # directory as a file within the top-level bucket, only the contents of the directory.
          if not prefix.endswith('/'):
              prefix += '/'

          file_list = list_s3_files(s3, bucket, prefix)

          try:
              with open(STATE_FILE, 'r') as f:
                  old_file_list = json.load(f)
                  known_filenames = set(f['key'] for f in old_file_list)
          except FileNotFoundError:
              old_file_list = []
              known_filenames = {}

          for filename in file_list:
              if filename not in known_filenames:
                  old_file_list.append({"bucket": bucket, "key": filename, "accessed": now})
                  file = download_s3_file(s3, bucket, filename)
                  sys.stdout.buffer.write(file)

          with open(STATE_FILE, 'w') as f:
              json.dump(old_file_list, f, indent=0)


      if __name__ == "__main__":
        main()

      END

          /opt/tenzir/libexec/uv run --no-project --with boto3 /tmp/script.py
      "#

        // The data is stored as compressed csv, see also https://docs.umbrella.com/deployment-umbrella/docs/dns-log-formats
        decompress_gzip
        read_csv header="timestamp,most_granular_identity,identities,internal_ip,external_ip,action,query_type,response_code,domain,categories,most_granular_identity_type,identity_types,blocked_categories,rule_id,destination_countries,organization_id"
      }
      @name = "cisco.umbrella.dns"
      publish "cisco"
    disabled: true

  umbrella-dns-to-ocsf:
    name: Umbrella DNS to OCSF DNS Activity
    description: |
      Maps CISCO Umbrella DNS logs to OCSF DNS Activity events.
    definition: |
      subscribe "cisco"
      where @name == "cisco.umbrella.dns"
      // Move original event into dedicated field.
      this = { event: this }
      // Assign some intermediate values for use in the next step, e.g., because
      // they're used multiple times.
      activity_id = 1
      // event.query_type looks like e.g. `16 (TXT)`
      query_type = event.query_type.parse_grok(r"%{NUMBER:value} \(%{WORD:name}\)")
      query = {
        hostname: event.domain,
        type: query_type.name,
      }
      let $ocsf_rcode_mapping = {
        NOERROR: {
          rcode_id: 0,
          rcode: "NoError",
        },
        FORMERROR: {
          rcode_id: 1,
          rcode: "FormError",
        },
        SERVERROR: {
          rcode_id: 2,
          rcode: "ServError",
        },
        SERVFAIL: {
          rcode_id: 2,
          rcode: "ServError",
        },
        NXDOMAIN: {
          rcode_id: 3,
          rcode: "NxDomain",
        },
        NOTIMP: {
          rcode_id: 4,
          rcode: "NotImp",
        },
        REFUSED: {
          rcode_id: 5,
          rcode: "Refused",
        },
        YXDOMAIN: {
          rcode_id: 6,
          rcode: "YXDomain",
        },
        YXRRSET: {
          rcode_id: 7,
          rcode: "YXRRSet",
        },
        NXRRSET: {
          rcode_id: 8,
          rcode: "NXRRSet",
        },
        NOTAUTH: {
          rcode_id: 9,
          rcode: "NotAuth",
        },
        NOTZONE: {
          rcode_id: 10,
          rcode: "NotZone",
        },
        DSOTYPENI: {
          rcode_id: 11,
          rcode: "DSOTYPENI",
        },
        BADSIG_VERS: {
          rcode_id: 16,
          rcode: "BADSIG_VERS",
        },
        BADKEY: {
          rcode_id: 17,
          rcode: "BADKEY",
        },
        BADTIME: {
          rcode_id: 18,
          rcode: "BADTIME",
        },
        BADMODE: {
          rcode_id: 19,
          rcode: "BADMODE",
        },
        BADNAME: {
          rcode_id: 20,
          rcode: "BADNAME",
        },
        BADALG: {
          rcode_id: 21,
          rcode: "BADALG",
        },
        BADTRUNC: {
          rcode_id: 22,
          rcode: "BADTRUNC",
        },
        BADCOOKIE: {
          rcode_id: 23,
          rcode: "BADCOOKIE",
        },
        UNASSIGNED: {
          rcode_id: 24,
          rcode: "Unassigned",
        },
        OTHER: {
          rcode_id: 99,
          rcode: "Other",
        },
      }
      if event.response_code == null {
        rcode_id = 99
        rcode = "Other"
      } else {
        rcode_id = $ocsf_rcode_mapping[event.response_code].rcode_id.otherwise(99)
        rcode = $ocsf_rcode_mapping[event.response_code].rcode.otherwise(event.response_code)
      }
      if event.action == "Denied" {
        action_id = 2
      } else if event.action == "Allowed" {
        action_id = 1
      } else {
        action_id = 0
      }
      action = event.action
      // Populate the OCSF event.
      this = {
        // --- Classification (required) ---
        type_uid: 400301,
        severity_id: 1,
        class_uid: 4003,
        category_uid: 4,
        activity_id: activity_id,
        // --- Context ---
        metadata: {
          product: {
            name: "Umbrella",
            vendor_name: "Cisco",
          },
          version: "1.3.0",
          profiles: ["security_control"]
        },
        unmapped: event,
        // --- Primary ---
        time: time(event.timestamp),
        src_endpoint: {
          ip: event.external_ip,
        },
        dst_endpoint: {
          name: "Cisco Umbrella DNS",
        },
        status_id: 1,
        rcode_id: rcode_id,
        rcode: rcode,
        query: query,
        // --- Security Control Profile ---
        action_id: action_id,
        action: action,
      }
      // Drop all mapped fields, with the effect that the remaining fields remain
      // in unmapped.
      drop(
        unmapped.timestamp,
        unmapped.external_ip,
        unmapped.response_code,
        unmapped.action,
        unmapped.query_type,
        unmapped.domain,
      )
      // Assign a new schema name to the transformed event.
      @name = "ocsf.dns_activity"
      publish "ocsf"
